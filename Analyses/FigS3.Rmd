---
title: "Comparison of single-cells versus pool-and-split samples"
author: "Catalina A. Vallejos"
date: '`r Sys.Date()`'
output:
  html_document:
      code_folding: hide
      toc: true
      toc_float: 
        collapsed: false
      number_sections: false 
---

To demonstrate the efficacy of our method, we use the control experiment described in Grun et al (2014), where single mouse embryonic stem cells (mESCs) are compared against \emph{pool-and-split} samples, consisting of pooled RNA from thousands of mESCs split into single-cell equivalent volumes. Such a controlled setting provides a situation where substantial changes in overall expression are not expected as, on average, the overall expression of single cells should match the levels measured on pool-and-split samples. Additionally, the design of pool-and-split samples removes biological variation, leading to a homogenous set of samples. Hence, pool-and-split samples are expected to show a genuine reduction in biological cell-to-cell heterogeneity when compared to single-cells. 

To start the analysis, the following data must be dowloaded and stored in `data.path` directory.

- \tt The expression counts: 'GSE54695_data_transcript_counts.txt' (source: \tt http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE54695). 
- The concentrations in the ERCC mix: 'cms_095046.txt'. The column names of this file have been modified to be readable from R (source: \tt https://tools.thermofisher.com/content/sfs/manuals/cms_095046.txt)

```{r set_global_options, cache=FALSE, results='hide', echo=FALSE, warning=FALSE, message=FALSE}
library('knitr')
opts_chunk$set(fig.path="/Users/catalinavallejos/Documents/OneDrive/Projects/SingleCell/BASiCS/Figures/GrunLN/")
#opts_chunk$set(fig.path="/Users/cvallejos/Documents/OneDrive/Projects/SingleCell/BASiCS/Figures/GrunLN/")
#opts_chunk$set(dev='pdf')
opts_chunk$set(dev='png')
```

```{r wd, echo=FALSE}
rm(list = ls())
data.path = "~/Documents/OneDrive/Projects/SingleCell/Datasets/Grun"
chains.path = "~/Documents/OneDrive/Projects/SingleCell/BASiCS/Chains/GrunLN"
results.path = "~/Documents/OneDrive/Projects/SingleCell/BASiCS/Results/GrunLN"
```

Additionally, the following R libraries must be loaded before performing the analysis

```{r libraries, message=FALSE, warning=FALSE}
library(BASiCS) # To run the analysis
packageVersion("BASiCS")
library(data.table) # For fast loading and processing of large datasets
packageVersion("data.table")
```

***

# Preparing the data

## Loading the data

```{r LoadCounts_2i}
input <- read.table(file.path(data.path,"GSE54695_data_transcript_counts.txt"), 
                    sep = "\t", header = TRUE)
rownames(input) <- input$GENENAME
input <- input[,-1]


# Select 2i conditions
input.2i <- input[,grepl("2i", colnames(input))]

# Batch info
Batch <- c(rep(1, 40), rep(2, 40), rep(1, 40), rep(2, 40))

# Generate raw UMI counts
UMICount <- function(MoleculeCount, UMILength)
{
  # MoleculeCount is the normalized count
  M = 4^UMILength
  UMICount = M*(1-exp(-MoleculeCount/M))
  return(UMICount)
}
CountsUMI = round(UMICount(input.2i, 4))

# Quality control - remove low Nanog cells
Pou5f1.per.cell <- as.numeric(CountsUMI["Pou5f1",])

CountsUMI_1 <- CountsUMI[,Pou5f1.per.cell >= 10]
CountsUMI.bio <- CountsUMI_1[!grepl("ERCC", rownames(CountsUMI_1)), ]
ERCC <- CountsUMI_1[grepl("ERCC", rownames(CountsUMI_1)), ]

CountsUMI.bio <- CountsUMI.bio[rowMeans(CountsUMI.bio) > 0.5,]
ERCC <- ERCC[rowMeans(ERCC) > 0,]
Batch <- Batch[Pou5f1.per.cell >= 10]

Data <- rbind(CountsUMI.bio, ERCC)
```

***

# BASiCS analysis

## The input dataset

To perform comparisons between two groups of cells, the current implementation of `BASiCS` requires the creation of two separate `BASiCS_Data` objects to contain separate information regarding each group. Two `BASiCS_Data` must be combined into one `BASiCS_D_Data` to perform comparisons between the corresponding groups of cells (using the function `CombineBASiCS_Data`). Similarly, two `BASiCS_Chain` object can be combined into a `BASiCS_D_Chain` object using the function `CombineBASiCS_Chain`. 

### Spike-in genes information 

In addition to the matrix of counts, the creation of `BASiCS_Data` and `BASiCS_D_Data` objects requires information regarding the number of spike-in molecules that are theoretically added to each cell. These quantities can be calculated based on the concentrations of ERCC molecules in the mix and the dilution factors used for library preparation. These are calculated below. 

```{r SpikeInfo_2i, warning=FALSE}
ERCC.conc <- read.table(file.path(data.path,"cms_095046.txt"), 
                        header=TRUE, sep = "\t", fill = TRUE)
ERCC.num <- matrix(data=NA, nrow=nrow(ERCC.conc), ncol=1)
ERCC.num[,1] <- (ERCC.conc[,4]*(10^(-18)))*(6.0221417*(10^23))

#### Pool and split data ####
input.ps <- Data[,grepl("SC", colnames(Data))]
input.rna <- Data[,grepl("RNA", colnames(Data))]

ERCC.num.final <- ERCC.num/2500000
rownames(ERCC.num) <- rownames(ERCC.num.final) <- ERCC.conc[,2]

SpikeInput <- ERCC.num.final[rownames(input.ps)[grepl("ERCC", rownames(input.ps))],1]
SpikeInput.1 <- data.frame("Name" = names(SpikeInput),
                           "Molecules" = SpikeInput, stringsAsFactors = FALSE)
```



### Creating the input object 

Firstly, the data objects that contain spike-in genes.

```{r NewData_2i}
Data.SC <- newBASiCS_Data(Counts = input.ps, 
                          Tech = grepl("ERCC", rownames(input.ps)), 
                          SpikeInfo = SpikeInput.1,
                          BatchInfo = Batch[grep("SC_2i",colnames(Data))])

Data.RNA <- newBASiCS_Data(Counts = input.rna, 
                           Tech = grepl("ERCC", rownames(input.rna)), 
                           SpikeInfo = SpikeInput.1,
                           BatchInfo = Batch[grep("RNA_2i",colnames(Data))])
```


To run the MCMC algorithm, we use the function `BASiCS_MCMC`. The following 
number of iterations, thining and burning periods will be used throughout

```{r MCMCparams}
N <- 20000; Thin <- 10; Burn <- 10000
```

Note: these data object contain spikes information. Therefore, the argument 
`WithSpikes` must be set equal to `FALSE` when running the `BASiCS_MCMC` function. 

## Fitting the BASiCS model: vertical integration - no regression
  
```{r MCMC1-names}
RunName1.SC <- paste0("Grun_Split2i_SC_LN_Nils_",N)
RunName1.RNA <- paste0("Grun_Split2i_RNA_LN_Nils_",N)
```

```{r MCMC1, eval = FALSE}
Chain1.SC <- BASiCS_MCMC(Data.SC, N = N, Thin = Thin, Burn = Burn,
                         PrintProgress = TRUE, StoreChains = TRUE, 
                         StoreDir = chains.path, RunName = RunName1.SC,
                         WithSpikes = TRUE, Regression = FALSE)

Chain1.RNA <- BASiCS_MCMC(Data.RNA, N = N, Thin = Thin, Burn = Burn,
                          PrintProgress = TRUE, StoreChains = TRUE, 
                          StoreDir = chains.path, RunName = RunName1.RNA,
                          WithSpikes = TRUE, Regression = FALSE)
```

This report shows the results of pre-computed chains as defined by the previous chunk of code. 

```{r BASiCS_MCMC_Load1}
Chain1.SC <- BASiCS_LoadChain(RunName = RunName1.SC, StoreDir = chains.path)
Chain1.RNA <- BASiCS_LoadChain(RunName = RunName1.RNA, StoreDir = chains.path)
```

Traceplots to assess convergence

```{r Traceplots1, fig.height = 3, fig.width = 6}
plot(Chain1.SC, Param = "mu", Gene = 1, log = "y")
plot(Chain1.SC, Param = "delta", Gene = 10)
plot(Chain1.RNA, Param = "mu", Gene = 100, log = "y")
plot(Chain1.RNA, Param = "delta", Gene = 1000)
```

## Fitting the BASiCS model: horizontal integration (single reference) - no reg

```{r MCMC2-names}
RunName2.SC <- paste0("Grun_Split2i_SC_NS_SingleRef_Nils_",N)
RunName2.RNA <- paste0("Grun_Split2i_RNA_NS_SingleRef_Nils_",N)
```

```{r MCMC2, eval = FALSE}
Chain2.SC <- BASiCS_MCMC(Data.SC, N = N, Thin = Thin, Burn = Burn,
                         PrintProgress = TRUE, StoreChains = TRUE, 
                         StoreDir = chains.path, RunName = RunName2.SC,
                         WithSpikes = FALSE, Regression = FALSE,
                         StochasticRef = FALSE)

Chain2.RNA <- BASiCS_MCMC(Data.RNA, N = N, Thin = Thin, Burn = Burn,
                          PrintProgress = TRUE, StoreChains = TRUE, 
                          StoreDir = chains.path, RunName = RunName2.RNA,
                          WithSpikes = FALSE, Regression = FALSE,
                          StochasticRef = FALSE)
```

```{r BASiCS_MCMC_Load2}
Chain2.SC <- BASiCS_LoadChain(RunName = RunName2.SC, StoreDir = chains.path)
Chain2.RNA <- BASiCS_LoadChain(RunName = RunName2.RNA, StoreDir = chains.path)
```

Traceplots to assess convergence

```{r Traceplots2, fig.height = 3, fig.width = 6}
plot(Chain2.SC, Param = "mu", Gene = 1, log = "y")
plot(Chain2.SC, Param = "delta", Gene = 10)
plot(Chain2.RNA, Param = "mu", Gene = 100, log = "y")
plot(Chain2.RNA, Param = "delta", Gene = 1000)
```

## Fitting the BASiCS model: horizontal integration (stoch reference) - no reg

```{r MCMC3-names}
RunName3.SC <- paste0("Grun_Split2i_SC_NS_StochRef_Nils_",N)
RunName3.RNA <- paste0("Grun_Split2i_RNA_NS_StochRef_Nils_",N)
```

```{r MCMC3, eval = FALSE}
Chain3.SC <- BASiCS_MCMC(Data.SC, N = N, Thin = Thin, Burn = Burn,
                         PrintProgress = TRUE, StoreChains = TRUE, 
                         StoreDir = chains.path, RunName = RunName3.SC,
                         WithSpikes = FALSE, Regression = FALSE,
                         StochasticRef = TRUE)
Chain3.RNA <- BASiCS_MCMC(Data.RNA, N = N, Thin = Thin, Burn = Burn,
                          PrintProgress = TRUE, StoreChains = TRUE, 
                          StoreDir = chains.path, RunName = RunName3.RNA,
                          WithSpikes = FALSE, Regression = FALSE,
                          StochasticRef = TRUE)
```

```{r BASiCS_MCMC_Load3}
Chain3.SC <- BASiCS_LoadChain(RunName = RunName3.SC, StoreDir = chains.path)
Chain3.RNA <- BASiCS_LoadChain(RunName = RunName3.RNA, StoreDir = chains.path)
```

Traceplots to assess convergence

```{r Traceplots3, fig.height = 3, fig.width = 6}
plot(Chain3.SC, Param = "mu", Gene = 1, log = "y")
plot(Chain3.SC, Param = "delta", Gene = 10)
plot(Chain3.RNA, Param = "mu", Gene = 100, log = "y")
plot(Chain3.RNA, Param = "delta", Gene = 1000)
```

## Fitting the BASiCS model: vertical integration - regression
  
```{r MCMC4-names}
RunName4.SC <- paste0("Grun_Split2i_SC_LN_Nils_Reg_",N)
RunName4.RNA <- paste0("Grun_Split2i_RNA_LN_Nils_Reg_",N)
```

```{r MCMC4, eval = FALSE}
Chain4.SC <- BASiCS_MCMC(Data.SC, N = N, Thin = Thin, Burn = Burn,
                         PrintProgress = TRUE, StoreChains = TRUE, 
                         StoreDir = chains.path, RunName = RunName4.SC,
                         WithSpikes = TRUE, Regression = TRUE)

Chain4.RNA <- BASiCS_MCMC(Data.RNA, N = N, Thin = Thin, Burn = Burn,
                          PrintProgress = TRUE, StoreChains = TRUE, 
                          StoreDir = chains.path, RunName = RunName4.RNA,
                          WithSpikes = TRUE, Regression = TRUE)
```

This report shows the results of pre-computed chains as defined by the previous chunk of code. 

```{r BASiCS_MCMC_Load4}
Chain4.SC <- BASiCS_LoadChain(RunName = RunName4.SC, StoreDir = chains.path)
Chain4.RNA <- BASiCS_LoadChain(RunName = RunName4.RNA, StoreDir = chains.path)
```

Traceplots to assess convergence

```{r Traceplots4, fig.height = 3, fig.width = 6}
plot(Chain4.SC, Param = "mu", Gene = 1, log = "y")
plot(Chain4.SC, Param = "delta", Gene = 10)
plot(Chain4.RNA, Param = "mu", Gene = 100, log = "y")
plot(Chain4.RNA, Param = "delta", Gene = 1000)
```

## Fitting the BASiCS model: horizontal integration (single reference) - reg

```{r MCMC5-names}
RunName5.SC <- paste0("Grun_Split2i_SC_NS_SingleRef_Nils_Reg_",N)
RunName5.RNA <- paste0("Grun_Split2i_RNA_NS_SingleRef_Nils_Reg_",N)
```

```{r MCMC5, eval = FALSE}
Chain5.SC <- BASiCS_MCMC(Data.SC, N = N, Thin = Thin, Burn = Burn,
                         PrintProgress = TRUE, StoreChains = TRUE, 
                         StoreDir = chains.path, RunName = RunName5.SC,
                         WithSpikes = FALSE, Regression = TRUE,
                         StochasticRef = FALSE)

Chain5.RNA <- BASiCS_MCMC(Data.RNA, N = N, Thin = Thin, Burn = Burn,
                          PrintProgress = TRUE, StoreChains = TRUE, 
                          StoreDir = chains.path, RunName = RunName5.RNA,
                          WithSpikes = FALSE, Regression = TRUE,
                          StochasticRef = FALSE)
```

```{r BASiCS_MCMC_Load5}
Chain5.SC <- BASiCS_LoadChain(RunName = RunName5.SC, StoreDir = chains.path)
Chain5.RNA <- BASiCS_LoadChain(RunName = RunName5.RNA, StoreDir = chains.path)
```

Traceplots to assess convergence

```{r Traceplots5, fig.height = 3, fig.width = 6}
plot(Chain5.SC, Param = "mu", Gene = 1, log = "y")
plot(Chain5.SC, Param = "delta", Gene = 10)
plot(Chain5.RNA, Param = "mu", Gene = 100, log = "y")
plot(Chain5.RNA, Param = "delta", Gene = 1000)
```

## Fitting the BASiCS model: horizontal integration (stoch reference) - reg

```{r MCMC6-names}
RunName6.SC <- paste0("Grun_Split2i_SC_NS_StochRef_Nils_Reg_",N)
RunName6.RNA <- paste0("Grun_Split2i_RNA_NS_StochRef_Nils_Reg_",N)
```

```{r MCMC6, eval = FALSE}
Chain6.SC <- BASiCS_MCMC(Data.SC, N = N, Thin = Thin, Burn = Burn,
                         PrintProgress = TRUE, StoreChains = TRUE, 
                         StoreDir = chains.path, RunName = RunName6.SC,
                         WithSpikes = FALSE, Regression = TRUE,
                         StochasticRef = TRUE)

Chain6.RNA <- BASiCS_MCMC(Data.RNA, N = N, Thin = Thin, Burn = Burn,
                          PrintProgress = TRUE, StoreChains = TRUE, 
                          StoreDir = chains.path, RunName = RunName6.RNA,
                          WithSpikes = FALSE, Regression = TRUE,
                          StochasticRef = TRUE)
```

```{r BASiCS_MCMC_Load6}
Chain6.SC <- BASiCS_LoadChain(RunName = RunName6.SC, StoreDir = chains.path)
Chain6.RNA <- BASiCS_LoadChain(RunName = RunName6.RNA, StoreDir = chains.path)
```

Traceplots to assess convergence

```{r Traceplots6, fig.height = 3, fig.width = 6}
plot(Chain6.SC, Param = "mu", Gene = 1, log = "y")
plot(Chain6.SC, Param = "delta", Gene = 10)
plot(Chain6.RNA, Param = "mu", Gene = 100, log = "y")
plot(Chain6.RNA, Param = "delta", Gene = 1000)
```

# Comparison: parameter estimation

```{r ComparisonFunctions}
OffsetCorrection <- function(Chain1, Chain2)
{ 
  Offset = median(rowSums(Chain2@parameters$mu)/rowSums(Chain1@parameters$mu)) 
  
  cat(paste("\n Estimated offset:", Offset, "\n"))
  
  out <- newBASiCS_Chain(parameters = list(mu = Chain2@parameters$mu / Offset,
                                           delta = Chain2@parameters$delta, 
                                           phi = Chain2@parameters$phi * Offset, 
                                           s = Chain2@parameters$s,
                                           nu = Chain2@parameters$nu,
                                           theta = Chain2@parameters$theta))
  return(out)
}

CompareEstimates <- function(Summary1, Summary2, 
                             Ref = NULL, FilterLim = NULL, 
                             col = "blue")
{
  col <- grDevices::rgb(grDevices::col2rgb(col)[1], 
                       grDevices::col2rgb(col)[2], 
                       grDevices::col2rgb(col)[3], 
                       50, maxColorValue = 255)
  ylab <- ifelse(is.null(Ref), 
                 "Horizontal integration (stoch ref)",
                 "Horizontal integration (fixed ref)")
  if(is.null(FilterLim)) { Genes <- seq_len(nrow(Summary1@parameters$mu)) } 
  else { Genes <- which(Summary1@parameters$mu[,1] > FilterLim) }
  
                
  plot(Summary1@parameters$mu[Genes,1],
       Summary2@parameters$mu[Genes,1], log = "xy",
       main = expression(paste("Posterior median ", mu[i])), 
       xlab = "Vertical integration",
       ylab = ylab, col = col, pch = 16, bty = "n")
  abline(a = 0, b = 1, lwd = 2, lty = 1)
  if(!is.null(Ref))
  {
    points(Summary1@parameters$mu[Ref,1],
           Summary2@parameters$mu[Ref,1], 
           pch = 16, col = "red", cex = 1)
    legend('topleft', c("Ref gene"), pch = 16, col = "red", cex = 1)    
  }
  
  plot(Summary1@parameters$delta[Genes,1],
       Summary2@parameters$delta[Genes,1], 
       main = expression(paste("Posterior median ", delta[i])), 
       xlab = "Vertical integration",
       ylab = ylab, col = col, pch = 16, bty = "n")
  abline(a = 0, b = 1, lwd = 2, lty = 1)
  if(!is.null(Ref))
  {
    points(Summary1@parameters$delta[Ref,1],
           Summary2@parameters$delta[Ref,1], 
          pch = 16, col = "red", cex = 1)
    legend('topleft', c("Ref gene"), pch = 16, col = "red", cex = 1)   
  }
}

CompareEstimatesMA <- function(Summary1, Summary2, 
                               Ref = NULL, FilterLim = NULL, 
                               col = "blue")
{
  col <- grDevices::rgb(grDevices::col2rgb(col)[1], 
                       grDevices::col2rgb(col)[2], 
                       grDevices::col2rgb(col)[3], 
                       50, maxColorValue = 255)
  ylab <- ifelse(is.null(Ref), 
                 "Vertical vs horizontal (stoch ref) log2-FC",
                 "Vertical vs horizontal (fixed ref) log2-FC")
  if(is.null(FilterLim)) { Genes <- seq_len(nrow(Summary1@parameters$mu)) } 
  else { Genes <- which(Summary1@parameters$mu[,1] > FilterLim) }
  
  n1 <- nrow(Summary1@parameters$phi); n2 <- nrow(Summary2@parameters$phi)
  Mu <- (n1 * Summary1@parameters$mu[Genes,1] + n2 * Summary2@parameters$mu[Genes,1])/(n1 + n2)
  
  plot(Mu[Genes], log2(Summary1@parameters$mu[Genes,1] / 
                         Summary2@parameters$mu[Genes,1]), log = "x",
       main = "Mean expression comparison",
       xlab = "Mean expression",
       ylab = ylab, col = col, pch = 16, bty = "n",
       ylim = c(-3, 3) )
  abline(h = 0, lwd = 2, lty = 1)
  abline(h = c(-log2(1.5), log2(1.5)), lwd = 2, lty = 2)
  if(!is.null(Ref))
  {
    points(Mu[Ref], log2(Summary1@parameters$mu[Ref,1] / 
                           Summary2@parameters$mu[Ref,1]), 
           pch = 16, col = "red", cex = 1)
    legend('topleft', c("Ref gene"), pch = 16, col = "red", cex = 1)    
  }
  
  plot(Mu, log2(Summary1@parameters$delta[Genes,1] / 
                  Summary2@parameters$delta[Genes,1]), log = "x",
       main = "Over-dispersion comparison",
       xlab = "Mean expression",
       ylab = ylab, col = col, pch = 16, bty = "n",
       ylim = c(-3, 3) )
  abline(h = 0, lwd = 2, lty = 1)
  abline(h = c(-log2(1.5), log2(1.5)), lwd = 2, lty = 2)
  if(!is.null(Ref))
  {
    points(Mu[Ref], log2(Summary1@parameters$delta[Ref,1] / 
                           Summary2@parameters$delta[Ref,1]), 
           pch = 16, col = "red", cex = 1)
    legend('topleft', c("Ref gene"), pch = 16, col = "red", cex = 1)   
  }
}

CompareHPDlength <- function(Summary1, Summary2, 
                             Ref = NULL, FilterLim = NULL,
                             col = "blue")
{
  
  col <- grDevices::rgb(grDevices::col2rgb(col)[1], 
                       grDevices::col2rgb(col)[2], 
                       grDevices::col2rgb(col)[3], 
                       50, maxColorValue = 255)
  ylab <- ifelse(is.null(Ref), 
                 "Horizontal integration (stoch ref)",
                 "Horizontal integration (fixed ref)")
  if(is.null(FilterLim)) { Genes <- seq_len(nrow(Summary1@parameters$mu)) } 
  else { Genes <- which(Summary1@parameters$mu[,1] > FilterLim) }
  
  plot(Summary1@parameters$mu[Genes,3] - Summary1@parameters$mu[Genes,2],
       Summary2@parameters$mu[Genes,3] - Summary2@parameters$mu[Genes,2], 
       log = "xy",
       main = expression(paste("HPD interval ", mu[i])),
       xlab = "Vertical integration",
       ylab = ylab, col = col, pch = 16, bty = "n")
  abline(a = 0, b = 1, lwd = 2, lty = 1)
  if(!is.null(Ref))
  {
    points(Summary1@parameters$mu[Ref,3] - Summary1@parameters$mu[Ref,2],
           Summary2@parameters$mu[Ref,3] - Summary2@parameters$mu[Ref,2],
           pch = 16, col = "red", cex = 1)
    legend('topleft', c("Ref gene"), pch = 16, col = "red", cex = 1)   
  }
  
  plot(Summary1@parameters$delta[Genes,3] - Summary1@parameters$delta[Genes,2],
       Summary2@parameters$delta[Genes,3] - Summary2@parameters$delta[Genes,2], 
       main = expression(paste("HPD interval ", delta[i])),
       xlab = "Vertical integration",
       ylab = ylab, col = col, pch = 16, bty = "n")
  abline(a = 0, b = 1, lwd = 2, lty = 1)
  if(!is.null(Ref))
  {
    points(Summary1@parameters$delta[Ref,3] - Summary1@parameters$delta[Ref,2],
           Summary2@parameters$delta[Ref,3] - Summary2@parameters$delta[Ref,2],
           pch = 16, col = "red", cex = 1)
    legend('topleft', c("Ref gene"), pch = 16, col = "red", cex = 1)    
  }
}

CompareHPDlengthMA <- function(Summary1, Summary2, 
                               Ref = NULL, FilterLim = NULL,
                               col = "blue")
{
  
  col <- grDevices::rgb(grDevices::col2rgb(col)[1], 
                       grDevices::col2rgb(col)[2], 
                       grDevices::col2rgb(col)[3], 
                       50, maxColorValue = 255)
  ylab <- ifelse(is.null(Ref), 
                 "Vertical vs horizontal (stoch ref) log2-FC",
                 "Vertical vs horizontal (fixed ref) log2-FC")
  if(is.null(FilterLim)) { Genes <- seq_len(nrow(Summary1@parameters$mu)) } 
  else { Genes <- which(Summary1@parameters$mu[,1] > FilterLim) }
  
  n1 <- nrow(Summary1@parameters$phi); n2 <- nrow(Summary2@parameters$phi)
  Mu <- (n1 * Summary1@parameters$mu[Genes,1] + n2 * Summary2@parameters$mu[Genes,1])/(n1 + n2)
  
  plot(Mu[Genes], log2((Summary1@parameters$mu[Genes,3] - Summary1@parameters$mu[Genes,2]) /
                       (Summary2@parameters$mu[Genes,3] - Summary2@parameters$mu[Genes,2])), 
       log = "x",
       main = "HPDlength mean expression comparison",
       xlab = "Mean expression",
       ylab = ylab, col = col, pch = 16, bty = "n",
       ylim = c(-3, 3) )
  abline(h = 0, lwd = 2, lty = 1)
  abline(h = c(-log2(1.5), log2(1.5)), lwd = 2, lty = 2)
  if(!is.null(Ref))
  {
    points(Mu[Ref], log2((Summary1@parameters$mu[Ref,3] - Summary1@parameters$mu[Ref,2]) /
                         (Summary2@parameters$mu[Ref,3] - Summary2@parameters$mu[Ref,2])),
           pch = 16, col = "red", cex = 1)
    legend('topleft', c("Ref gene"), pch = 16, col = "red", cex = 1)   
  }
  
  plot(Mu[Genes], log2((Summary1@parameters$delta[Genes,3] - Summary1@parameters$delta[Genes,2]) /
                       (Summary2@parameters$delta[Genes,3] - Summary2@parameters$delta[Genes,2])), log = "x",
  main = "HPDlength over-dispersion comparison",
  xlab = "Mean expression",
  ylab = ylab, col = col, pch = 16, bty = "n",
  ylim = c(-3, 3) )
  abline(h = 0, lwd = 2, lty = 1)
  abline(h = c(-log2(1.5), log2(1.5)), lwd = 2, lty = 2)
  if(!is.null(Ref))
  {
    points(Mu[Ref], log2((Summary1@parameters$delta[Ref,3] - Summary1@parameters$delta[Ref,2]) /
                         (Summary2@parameters$delta[Ref,3] - Summary2@parameters$delta[Ref,2])),
           pch = 16, col = "red", cex = 1)
    legend('topleft', c("Ref gene"), pch = 16, col = "red", cex = 1)    
  }
}
```

```{r OffsetCorrect}
# Removal global offsets between horizontal and vertical versions
Chain2.SC.o <- OffsetCorrection(Chain1.SC, Chain2.SC)
Chain3.SC.o <- OffsetCorrection(Chain1.SC, Chain3.SC)
Chain2.RNA.o <- OffsetCorrection(Chain1.RNA, Chain2.RNA)
Chain3.RNA.o <- OffsetCorrection(Chain1.RNA, Chain3.RNA)
Chain5.SC.o <- OffsetCorrection(Chain4.SC, Chain5.SC)
Chain6.SC.o <- OffsetCorrection(Chain4.SC, Chain6.SC)
Chain5.RNA.o <- OffsetCorrection(Chain4.RNA, Chain5.RNA)
Chain6.RNA.o <- OffsetCorrection(Chain4.RNA, Chain6.RNA)

Summary1.SC <- Summary(Chain1.SC)
Summary1.RNA <- Summary(Chain1.RNA)
Summary2.SC <- Summary(Chain2.SC.o)
Summary2.RNA <- Summary(Chain2.RNA.o)
Summary3.SC <- Summary(Chain3.SC.o)
Summary3.RNA <- Summary(Chain3.RNA.o)
Summary4.SC <- Summary(Chain4.SC)
Summary4.RNA <- Summary(Chain4.RNA)
Summary5.SC <- Summary(Chain5.SC.o)
Summary5.RNA <- Summary(Chain5.RNA.o)
Summary6.SC <- Summary(Chain6.SC.o)
Summary6.RNA <- Summary(Chain6.RNA.o)
```

## Single cells (no regression)

```{r ComparisonParamGrun2iSC_noreg, fig.height = 6, fig.width = 6}
Ref.SC <- read.table(file.path(chains.path, 
                            paste0("TableRef_", RunName2.SC, ".txt")),
                  header = TRUE)$GeneIndex

Refs.SC <- read.table(file.path(chains.path, 
                            paste0("TableRef_", RunName3.SC, ".txt")),
                      header = TRUE)$GeneIndex

par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimates(Summary1.SC, Summary2.SC, Ref.SC)
CompareHPDlength(Summary1.SC, Summary2.SC, Ref.SC)


par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimates(Summary1.SC, Summary3.SC, Refs.SC)
CompareHPDlength(Summary1.SC, Summary3.SC, Refs.SC)
```


```{r ComparisonParamGrun2iSC_MA, fig.width=8, fig.height=8}
par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimatesMA(Summary1.SC, Summary2.SC, Ref.SC)
CompareHPDlengthMA(Summary1.SC, Summary2.SC, Ref.SC)


par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimatesMA(Summary1.SC, Summary3.SC, Refs.SC)
CompareHPDlengthMA(Summary1.SC, Summary3.SC, Refs.SC)
```

## Single cells (regression)

```{r ComparisonParamGrun2iSC_reg, fig.height = 6, fig.width = 6}
Ref.SC <- read.table(file.path(chains.path, 
                            paste0("TableRef_", RunName5.SC, ".txt")),
                  header = TRUE)$GeneIndex

Refs.SC <- read.table(file.path(chains.path, 
                            paste0("TableRef_", RunName6.SC, ".txt")),
                      header = TRUE)$GeneIndex

par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimates(Summary4.SC, Summary5.SC, Ref.SC)
CompareHPDlength(Summary4.SC, Summary5.SC, Ref.SC)


par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimates(Summary4.SC, Summary6.SC, Refs.SC)
CompareHPDlength(Summary4.SC, Summary6.SC, Refs.SC)
```


```{r ComparisonParamGrun2iSC_MA_reg, fig.width=8, fig.height=8}
par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimatesMA(Summary4.SC, Summary5.SC, Ref.SC)
CompareHPDlengthMA(Summary4.SC, Summary5.SC, Ref.SC)


par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimatesMA(Summary4.SC, Summary6.SC, Refs.SC)
CompareHPDlengthMA(Summary4.SC, Summary6.SC, Refs.SC)
```


## Pool and split samples (no regression)

```{r ComparisonParamGrun2iRNA, fig.width=8, fig.height=8}
Ref.RNA <- read.table(file.path(chains.path, 
                            paste0("TableRef_", RunName2.RNA, ".txt")),
                  header = TRUE)$GeneIndex

par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimates(Summary1.RNA, Summary2.RNA, Ref.RNA)
CompareHPDlength(Summary1.RNA, Summary2.RNA, Ref.RNA)


par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimates(Summary1.RNA, Summary3.RNA)
CompareHPDlength(Summary1.RNA, Summary3.RNA)
```

```{r ComparisonParamGrun2iRNA_MA, fig.width=8, fig.height=8}
par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimatesMA(Summary1.RNA, Summary2.RNA, Ref.RNA)
CompareHPDlengthMA(Summary1.RNA, Summary2.RNA, Ref.RNA)


par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimatesMA(Summary1.RNA, Summary3.RNA)
CompareHPDlengthMA(Summary1.RNA, Summary3.RNA)
```

## Pool-and-split samples (regression)

```{r ComparisonParamGrun2iRNA_reg, fig.height = 6, fig.width = 6}
Ref.RNA <- read.table(file.path(chains.path, 
                            paste0("TableRef_", RunName5.RNA, ".txt")),
                  header = TRUE)$GeneIndex

Refs.RNA <- read.table(file.path(chains.path, 
                            paste0("TableRef_", RunName6.RNA, ".txt")),
                      header = TRUE)$GeneIndex

par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimates(Summary4.RNA, Summary5.RNA, Ref.RNA)
CompareHPDlength(Summary4.RNA, Summary5.RNA, Ref.RNA)


par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimates(Summary4.RNA, Summary6.RNA, Refs.RNA)
CompareHPDlength(Summary4.RNA, Summary6.RNA, Refs.RNA)
```


```{r ComparisonParamGrun2iRNA_MA_reg, fig.width=8, fig.height=8}
par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimatesMA(Summary4.RNA, Summary5.RNA, Ref.RNA)
CompareHPDlengthMA(Summary4.RNA, Summary5.RNA, Ref.RNA)


par(mfrow = c(2,2))
#par(mar = c(5, 6, 5, 2) + 0.1)
#par(cex.axis = 2)
#par(cex.lab = 2, cex.main = 2.5)
CompareEstimatesMA(Summary4.RNA, Summary6.RNA, Refs.RNA)
CompareHPDlengthMA(Summary4.RNA, Summary6.RNA, Refs.RNA)
```
